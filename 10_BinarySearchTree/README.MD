# ДЗ

Требуется реализовать функции в пространствах имен
`Homework::BST`

### 1. Обработка чеков

★★★☆☆

Компания по грузоперевозкам генерирует огромное количество чеков каждый день - оплата горючего, ремонтов, проезда по
платным дорогам. Компании необходимо реализовать возможность быстрого поиска по ним, поэтому ИТ отдел принял решение
использовать бинарное дерево поиска. Перед вами поставили задачу:
В пространстве имен `Homework::BST` надо реализовать функцию,

```c++
Node* FromList(const std::vector<Receipt>& elements); 
```

Метод должен вернуть ссылку на корень дерева. На вход же ему поступает коллекция чеков. В каждом чеке указан его номер,
по которому необходимо сортировать и сумма. Классы Node и Receipt для вас уже подготовил техотдел.
*Внимание!* Чеки приходят не в отсортированном порядке.

### 2. Выгрузить все чеки за день

★★★☆☆

Ваш босс так же захотел иметь возможность получить список всех чеков за определенный день. Теперь перед вами стоит
задача развернуть в список, имея ссылку на корень бинарного дерева поиска. Реализуйте функцию:

```c++
std::vector<Receipt> FromNode(Node* root);
```

### 3. Быстрый поиск чека

★★★☆☆

Следующей задачей, которую вам необходимо выполнить - поиск нужного чека в дереве. Вам необходимо найти чек по номеру, и
вернуть сумму, которая в нем указана. Для этого реализуйте функцию:

```c++
double GetAmount(Node* root, size_t receiptNumber);
```

### 4. Проблема с базой данных

★★★☆☆

В ходе работы программы, пользователи заметили, что иногда из-за ошибок сервера, в программу загружаются "битые" чеки и
дерево теряет свое основное свойство - значение номера чека в родителе меньше чем в потомках. Реализуйте метод проверки,
который проверял бы действительно ли дерево загрузилось правильно. Для этого реализуйте функцию:

```c++
bool CheckTree(Node* root);
```

### 5. Удаляем неверные чеки

★★★☆☆

Часто чеки загружают с ошибочной датой. И такие чеки надо удалять из дерева. Для этого реализуйте функцию:

```java
Node* Delete(Node* root, size_t receipt);
```

### 6. Следующий чек

★★★☆☆

Для улучшения отображения в бухгалтерской программе, техотдел предложил выгружать следующий чек, после отображаемого.
Для этого реализуйте функцию, которая бы возвращала следующий чек после чека receipt, если его нет вернуть `Receipt{}`:

```с++
Receipt GetNext(Node* root, const Receipt& receipt);
```

